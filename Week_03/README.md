学习笔记
泛型递归、树的递归
树的面试题解法一般都是递归
原因why？
1.节点的定义
它的节点和树本身数据结构的定义就是用递归的方式进行的
2.重复性(自相似性)
不仅是树本身、二叉树以及二叉搜索树，在定义它的数据结构和算法特性的时候，存在重复性即自相似性 
以二叉搜索树举例，定义左子树都要小于根节点，右子树都要大于根节点，且左右子树具有相似的特征，以此类推，左右子树也满足以上特点
i

递归需要注意的点、代码模板结构
1.递归的终结条件
2.处理当前层逻辑
3.下探到下一层
4.清理当前层关系
递归本身的特点
本质上类似于循环，通过函数体调用本身来进行循环，没有明显的边界
每一层递归相应的时间会变慢
1.向下进入到不同的递归层，向上又回到原来的一层
"不能跳！只能一层层一次递归下去，具有对称性"
2.用参数进行同步
3.函数里的参数与全局变量可以在不同的递归层发生携带与变化，不同的递归层不会相互影响

计算n! python
n! = 1* 2 * 3 * …… * n
def Factorial(n)
  if n <= 1:
    return 1
  return n * Factorial(n-1)

思维要点
1.不要进行人肉递归(最大误区)不要自己画递归状态树
2.找最近最简方法，将其拆解成可重复解决的问题（重复子问题）
3.数学归纳法思维 最开始最简单的条件是成立的 比如n=1或n=2时成立且能证明当n成立的时候可以推出n+1也是成立的

python

def recursion(level, param1, param2, …):
    # recursion terminator
    if level > max_level:
      process_result
      return
      
    # process logic in current level
    process(level, data…)

    # drill down
    self.recursion(level+1, param1 ,param2 …)

    # reverse the current level status if needed

相应的递归面试题
爬楼梯 斐波那契数列
括号生成
翻转二叉树
验证二叉搜索树
二叉树最大深度 最小深度
二叉树的序列化和反序列化
二叉树的最近公共祖先

